{"version":3,"file":"infinite-viewer.min.js","sources":["../src/consts.ts","../src/utils.ts","../src/ScrollBar.ts","../src/index.umd.ts","../src/BounceScrollBar.ts","../src/InfiniteViewer.tsx","../src/InfiniteViewerManager.tsx"],"sourcesContent":["import styled from \"css-styled\";\nimport { InfiniteViewerOptions } from \"./types\";\nimport getAgent from \"@egjs/agent\";\nimport { prefixCSS } from \"framework-utils\";\n\nexport const agent = getAgent();\nexport const IS_SAFARI = agent.browser.name === \"safari\";\n\nexport const PREFIX = \"infinite-viewer-\";\n\nexport const WRAPPER_CLASS_NAME = `${PREFIX}wrapper`;\nexport const SCROLL_AREA_CLASS_NAME = `${PREFIX}scroll-area`;\n\nexport const SCROLL_BAR_CLASS_NAME = `${PREFIX}scroll-bar`;\nexport const HORIZONTAL_SCROLL_BAR_CLASS_NAME = `${PREFIX}horizontal-scroll-bar`;\nexport const VERTICAL_SCROLL_BAR_CLASS_NAME = `${PREFIX}vertical-scroll-bar`;\nexport const SCROLL_THUMB_CLASS_NAME = `${PREFIX}scroll-thumb`;\n\nexport const injector = styled(prefixCSS(PREFIX, `\n{\n    position: relative;\n    overscroll-behavior: none;\n}\n.wrapper {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: auto;\n    scrollbar-width: none;\n    top: 0;\n    left: 0;\n    will-change: scroll-position;\n}\n.restrict-wrapper {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n}\n.wrapper::-webkit-scrollbar {\n    display: none;\n}\n.scroll-area {\n    position:absolute;\n    top:0;\n    left:0;\n    transform-origin: 0 0;\n}\n.scroll-bar {\n    position:absolute;\n    width: 10px;\n    height: 10px;\n    box-sizing: border-box;\n    right: 0;\n    bottom: 0;\n    overflow: hidden;\n}\n.horizontal-scroll-bar {\n    width: calc(100% - 20px);\n    right: 10px;\n    height: 14px;\n}\n.vertical-scroll-bar {\n    height: calc(100% - 20px);\n    bottom: 10px;\n    width: 14px;\n}\n.scroll-thumb {\n    position:relative;\n    opacity: 0.7;\n    background: #333;\n    border-radius: 3px;\n    left: 0px;\n    top: 0px;\n    z-index: 10;\n    width: 6px;\n    height: 6px;\n    transition: all ease 0.2s;\n    opacity: 0;\n}\n.scroll-bar:hover .scroll-thumb {\n    border-radius: 5px;\n    opacity: 1;\n}\n.horizontal-scroll-bar .scroll-thumb {\n    margin: 4px 0px;\n    transition-property: opacity, margin, height, border-radius;\n}\n.vertical-scroll-bar .scroll-thumb {\n    margin: 0px 4px;\n    transition-property: opacity, margin, width, border-radius;\n}\n.horizontal-scroll-bar:hover .scroll-thumb {\n    height: 10px;\n    margin: 2px 0px;\n}\n.vertical-scroll-bar:hover .scroll-thumb {\n    width: 10px;\n    margin: 0px 2px;\n}\n`));\n\nexport const DEFAULT_OPTIONS = {\n    margin: 500,\n    threshold: 100,\n    zoom: 1,\n    zoomX: 1,\n    zoomY: 1,\n    rangeX: [-Infinity, Infinity],\n    rangeY: [-Infinity, Infinity],\n    rangeOffsetX: [0, 0],\n    rangeOffsetY: [0, 0],\n    wrapperElement: null,\n    scrollAreaElement: null,\n    horizontalScrollElement: null,\n    verticalScrollElement: null,\n    usePinch: false,\n    useAutoZoom: false,\n    useMouseDrag: false,\n    pinchThreshold: 30,\n    cspNonce: \"\",\n    maxPinchWheel: Infinity,\n    wheelScale: 0.01,\n    displayHorizontalScroll: true,\n    displayVerticalScroll: true,\n    useTransform: true,\n    useWheelPinch: true,\n    zoomRange: [0.001, Infinity],\n    wheelPinchKey: \"ctrl\" as const,\n    useWheelScroll: IS_SAFARI,\n    zoomOffsetX: \"50%\",\n    zoomOffsetY: \"50%\",\n    translateZ: 0,\n    useGesture: true,\n    useResizeObserver: false,\n    pinchDirection: \"all\" as const,\n    preventWheelClick: true,\n    useBounceScrollBar: false,\n};\n\nexport const DEFAULT_EASING = (x: number) => 1 - Math.pow(1 - x, 3);\nexport const NAMES = {\n    horizontal: {\n        pos: \"Left\",\n        coord: \"X\",\n        size: \"Width\",\n    },\n    vertical: {\n        pos: \"Top\",\n        coord: \"Y\",\n        size: \"Height\",\n    },\n} as const;\n/**\n * @memberof InfiniteViewer\n */\nexport const CLASS_NAME = injector.className;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const PROPERTIES = [\n    \"margin\",\n    \"threshold\",\n    \"zoomOffsetX\",\n    \"zoomOffsetY\",\n    \"zoom\",\n    \"zoomX\",\n    \"zoomY\",\n    \"rangeX\",\n    \"rangeY\",\n    \"rangeOffsetX\",\n    \"rangeOffsetY\",\n    \"usePinch\",\n    \"useMouseDrag\",\n    \"pinchThreshold\",\n    \"maxPinchWheel\",\n    \"wheelScale\",\n    \"displayVerticalScroll\",\n    \"displayHorizontalScroll\",\n    \"translateZ\",\n    \"useAutoZoom\",\n    \"wheelPinchKey\",\n    \"zoomRange\",\n    \"pinchDirection\",\n] as const;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const OPTIONS = [\n    // ignore target, container,\n    ...PROPERTIES,\n    \"preventWheelClick\",\n    \"useWheelPinch\",\n    \"useWheelScroll\",\n    \"useGesture\",\n    \"cspNonce\",\n    \"wrapperElement\",\n    \"scrollAreaElement\",\n    \"verticalScrollElement\",\n    \"horizontalScrollElement\",\n    \"useResizeObserver\",\n    \"wheelContainer\",\n    \"useBounceScrollBar\",\n] as const;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const EVENTS = [\n    \"scroll\",\n    \"abortPinch\",\n    \"dragStart\",\n    \"dragEnd\",\n    \"pinchStart\",\n    \"pinch\",\n] as const;\n\n/**\n * @memberof InfiniteViewer\n */\nexport const METHODS = [\n    \"getScrollLeft\",\n    \"getScrollTop\",\n    \"getScrollWidth\",\n    \"getScrollHeight\",\n    \"getContainerWidth\",\n    \"getContainerHeight\",\n    \"getViewportWidth\",\n    \"getViewportHeight\",\n    \"getViewportScrollWidth\",\n    \"getViewportScrollHeight\",\n    \"scrollTo\",\n    \"scrollBy\",\n    \"zoomBy\",\n    \"scrollCenter\",\n    \"getContainer\",\n    \"getViewport\",\n    \"getWrapper\",\n    \"setZoom\",\n    \"getRangeX\",\n    \"getRangeY\",\n    \"resize\",\n    \"getZoom\",\n    \"getZoomX\",\n    \"getZoomY\",\n    \"getWheelContainer\",\n    \"setTo\",\n    \"setBy\",\n] as const;\n\nexport const TINY_NUM = 0.000001;\n","import { OnDrag } from \"gesto\";\nimport { TINY_NUM } from \"./consts\";\nimport { AnimationOptions } from \"./types\";\n\nexport function measureSpeed(e: OnDrag) {\n    const { deltaX, deltaY, datas } = e;\n    const time = Date.now();\n    const prevSpeed = datas.speed;\n\n    if (!prevSpeed) {\n        datas.speed = [0, 0];\n        datas.time = time;\n        return;\n    }\n    const dt = time - datas.time;\n    datas.speed = [prevSpeed[0] / 2 + deltaX / dt, prevSpeed[1] / 2 + deltaY / dt];\n}\n\nexport function getDuration(speed: number[], a: number) {\n    const normalSpeed = Math.sqrt(speed[0] * speed[0] + speed[1] * speed[1]);\n\n    return Math.abs(normalSpeed / a);\n}\nexport function getDestPos(speed: number[], a: number) {\n    const duration = getDuration(speed, a);\n\n    return [\n        -speed[0] / 2 * duration,\n        -speed[1] / 2 * duration,\n    ];\n}\nexport function minmax(value: number, min: number, max: number) {\n    return Math.min(max, Math.max(min, value));\n}\n\nexport function abs(v: number) {\n    return Math.abs(v);\n}\n\nexport function getRange(\n    pos: number,\n    margin: number,\n    range: number[],\n    threshold: number,\n    isReal: boolean,\n) {\n    const min = isReal || isFinite(range[0])\n        ? range[0]\n        : Math.min(-1, Math.floor(pos / margin)) * margin - threshold;\n    const max = isReal || isFinite(range[1])\n        ? range[1]\n        : Math.max(1, Math.ceil(pos / margin)) * margin + threshold;\n\n    return [min, max];\n}\n\nexport function throttle(value: number) {\n    return Math.round(value / TINY_NUM) * TINY_NUM;\n}\n\n\nexport function checkDefault<T>(value: T | undefined | null, defaultValue: T): T {\n    return value != null ? value : defaultValue;\n}\n\n\n\nexport function startAnimation(\n    callback: (ratioDist: number) => void,\n    timerCallback: (next: () => void) => void,\n    options: AnimationOptions,\n) {\n    const duration = options.duration;\n    const easing = options.easing || ((x: number) => 1 - Math.pow(1 - x, 3));\n    const startTime = Date.now();\n    let prevTime = startTime;\n\n    const next = () => {\n        const now = Date.now();\n        let t = now - startTime;\n\n        if (duration < t) {\n            t = duration;\n        }\n        const ratio = easing(t / duration);\n        const prevRatio = easing((prevTime - startTime) / duration);\n\n        prevTime = now;\n\n        callback(ratio - prevRatio);\n\n        if (t >= duration) {\n            return;\n        }\n        timerCallback(next);\n    };\n    timerCallback(next);\n}\n","import Gesto, { OnDrag, OnDragStart } from \"gesto\";\nimport {\n    SCROLL_BAR_CLASS_NAME, SCROLL_THUMB_CLASS_NAME,\n    HORIZONTAL_SCROLL_BAR_CLASS_NAME, VERTICAL_SCROLL_BAR_CLASS_NAME\n} from \"./consts\";\nimport { addClass, removeEvent, addEvent, throttle } from \"@daybrush/utils\";\nimport EventEmitter from \"@scena/event-emitter\";\nimport { abs } from \"./utils\";\n\nexport default class ScrollBar extends EventEmitter {\n    public isAppend: boolean = false;\n    public thumbElement!: HTMLElement;\n    public barElement!: HTMLElement;\n    protected gesto!: Gesto;\n    protected size: number = 0;\n    protected scrollSize: number = 0;\n    protected isHorizontal = false;\n\n    constructor(\n        public type: \"horizontal\" | \"vertical\",\n        container?: HTMLElement,\n    ) {\n        super();\n        const isHorizontal = type === \"horizontal\";\n        let thumbElement: HTMLElement;\n        let barElement: HTMLElement = container;\n\n        if (!container) {\n            barElement = document.createElement(\"div\");\n            thumbElement = document.createElement(\"div\");\n\n            barElement.insertBefore(thumbElement, null);\n            this.isAppend = true;\n        } else {\n            thumbElement = container.querySelector(`.${SCROLL_THUMB_CLASS_NAME}`);\n        }\n        addClass(\n            barElement,\n            isHorizontal ? HORIZONTAL_SCROLL_BAR_CLASS_NAME\n                : VERTICAL_SCROLL_BAR_CLASS_NAME,\n        );\n        addClass(barElement, SCROLL_BAR_CLASS_NAME);\n        addClass(thumbElement, SCROLL_THUMB_CLASS_NAME);\n\n        this.thumbElement = thumbElement;\n        this.barElement = barElement;\n        this.isHorizontal = isHorizontal;\n        this.gesto = new Gesto(barElement, {\n            container: window,\n        }).on(\n            \"dragStart\",\n            e => this._onDragStart(e),\n        ).on(\n            \"drag\",\n            e => this._onDrag(e),\n        );\n        addEvent(this.barElement, \"wheel\", this._onWheel, {\n            passive: false,\n        });\n    }\n    public scrollBy(delta: number, isAbsolute?: boolean) {\n        const ratio = delta / this.size;\n\n        this.trigger(\"scroll\", {\n            delta: isAbsolute ? delta : this.scrollSize * ratio,\n        });\n    }\n    public render = () => {\n    }\n    public renderDefault(\n        isDisplay: boolean,\n        containerSize: number,\n        scrollRange: number[],\n    ) {\n        const [startMargin, endMargin] = scrollRange;\n        const scrollSizeOffset = throttle(abs(startMargin) + endMargin, 0.001);\n        const scrollSize = containerSize + scrollSizeOffset;\n        const opacity = isDisplay && scrollSizeOffset ? \"1\" : \"\";\n        const [dirName1, sizeName] = this.isHorizontal ? [\"X\", \"width\"] : [\"Y\", \"height\"];\n        const thumbSize = containerSize / scrollSize;\n        const thumbPos = endMargin / scrollSize / thumbSize;\n\n        this.size = containerSize;\n        this.scrollSize = scrollSize;\n        this.thumbElement.style.opacity = opacity;\n        this.thumbElement.style.cssText\n            += `${sizeName}: ${thumbSize * 100}%;`\n            + `transform: translate${dirName1}(${thumbPos * 100}%)`;\n    }\n    public destroy() {\n        removeEvent(this.barElement, \"wheel\", this._onWheel);\n        this.gesto.off();\n        this.off();\n    }\n    protected _onDragStart = (e: OnDragStart) => {\n        const isHorizontal = this.isHorizontal;\n        const target = e.inputEvent.target;\n        const datas = e.datas;\n        const isThumb = this.thumbElement === target;\n\n        if (!isThumb) {\n            setTimeout(() => {\n                requestAnimationFrame(() => {\n                    const thumbRect = this.thumbElement.getBoundingClientRect();\n                    const pos1 = thumbRect[isHorizontal ? \"left\" : \"top\"];\n                    const thumbSize = thumbRect[isHorizontal ? \"width\" : \"height\"];\n                    const pos2 = pos1 + thumbSize;\n                    const clientPos = e[isHorizontal ? \"clientX\" : \"clientY\"];\n\n                    const endPos = clientPos - pos2;\n                    const startPos = clientPos - pos1;\n\n                    if (0 <= startPos && endPos <= 0) {\n                        return;\n                    }\n                    const clientScrollWidth = thumbSize / this.size * this.scrollSize;\n                    const pos = (0 < endPos ? endPos : startPos) / clientScrollWidth;\n                    const delta = pos * this.size;\n\n                    this.scrollBy(delta);\n                });\n            }, 100);\n\n        }\n        datas.isThumb = isThumb;\n        e.inputEvent.stopPropagation();\n        e.inputEvent.preventDefault();\n    };\n    protected _onDrag = (e: OnDrag) => {\n        if (!e.datas.isThumb) {\n            return;\n        }\n        this.scrollBy(this.isHorizontal ? e.deltaX : e.deltaY);\n    };\n    protected _onWheel = (e: WheelEvent) => {\n        const delta = this.isHorizontal ? e.deltaX : e.deltaY;\n\n        if (delta) {\n            e.preventDefault();\n        }\n        this.trigger(\"scroll\", {\n            delta,\n        });\n    }\n}\n","import InfiniteViewer, * as modules from \"./index\";\n\nfor (const name in modules) {\n    (InfiniteViewer as any)[name] = modules[name];\n}\n\nexport default InfiniteViewer;\n","import Gesto, { OnDragStart } from \"gesto\";\nimport {\n    SCROLL_BAR_CLASS_NAME, SCROLL_THUMB_CLASS_NAME,\n    HORIZONTAL_SCROLL_BAR_CLASS_NAME, VERTICAL_SCROLL_BAR_CLASS_NAME\n} from \"./consts\";\nimport { addClass, removeEvent, addEvent } from \"@daybrush/utils\";\nimport EventEmitter from \"@scena/event-emitter\";\nimport ScrollBar from \"./ScrollBar\";\n\nexport default class BounceScrollBar extends ScrollBar {\n    public renderBounce(\n        isDisplay: boolean,\n        pos: number,\n        size: number,\n        scrollSize: number,\n    ) {\n        this.size = size;\n        this.scrollSize = scrollSize;\n\n        const display = isDisplay && (scrollSize > size) ? \"block\" : \"none\";\n        const [dirName1, sizeName] = this.isHorizontal ? [\"X\", \"width\"] : [\"Y\", \"height\"];\n\n        this.barElement.style.cssText = `display: ${display};`;\n        this.thumbElement.style.cssText\n            += `${sizeName}: ${size * size / scrollSize}px;opacity: 1;`\n            + `transform: translate${dirName1}(${pos / scrollSize * size}px)`;\n    }\n    protected _onDragStart = (e: OnDragStart<Gesto>) => {\n        const isHorizontal = this.isHorizontal;\n        const target = e.inputEvent.target;\n        const datas = e.datas;\n        const isThumb = this.thumbElement === target;\n\n        if (!isThumb) {\n            setTimeout(() => {\n                requestAnimationFrame(() => {\n                    const thumbRect = this.thumbElement.getBoundingClientRect();\n                    const pos1 = thumbRect[isHorizontal ? \"left\" : \"top\"];\n                    const thumbSize = thumbRect[isHorizontal ? \"width\" : \"height\"];\n                    const pos2 = pos1 + thumbSize;\n                    const clientPos = e[isHorizontal ? \"clientX\" : \"clientY\"];\n\n                    if (pos1 <= clientPos && clientPos <= pos2) {\n                        return;\n                    }\n                    const size = this.size;\n                    const delta = size * size / this.scrollSize;\n\n                    this.scrollBy(pos1 < clientPos ? delta : -delta);\n                });\n            }, 100);\n\n        }\n        datas.isThumb = isThumb;\n        e.inputEvent.stopPropagation();\n        e.inputEvent.preventDefault();\n    }\n}\n","import InfiniteViewerManager from \"./InfiniteViewerManager\";\n\nexport default class InfiniteViewer extends InfiniteViewerManager {}\n","import EventEmitter from \"@scena/event-emitter\";\nimport Gesto from \"gesto\";\nimport { InjectResult } from \"css-styled\";\nimport { Properties } from \"framework-utils\";\nimport { camelize, IObject, addEvent, removeEvent, addClass, convertUnitSize, between, isObject, isArray, isString } from \"@daybrush/utils\";\nimport { InfiniteViewerOptions, InfiniteViewerProperties, InfiniteViewerEvents, OnPinch, AnimationOptions, ScrollOptions, ZoomOptions, GetScollPosOptions, InnerScrollOptions, ScrollCenterOptions, SetOptions } from \"./types\";\nimport {\n    PROPERTIES, injector, CLASS_NAME, TINY_NUM,\n    DEFAULT_OPTIONS,\n    WRAPPER_CLASS_NAME, SCROLL_AREA_CLASS_NAME,\n    HORIZONTAL_SCROLL_BAR_CLASS_NAME, VERTICAL_SCROLL_BAR_CLASS_NAME, NAMES, DEFAULT_EASING,\n} from \"./consts\";\nimport { measureSpeed, getDuration, getDestPos, abs, getRange, checkDefault, startAnimation } from \"./utils\";\nimport ScrollBar from \"./ScrollBar\";\nimport BounceScrollBar from \"./BounceScrollBar\";\n\n@Properties(PROPERTIES as any, (prototype, property) => {\n    const attributes: IObject<any> = {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.options[property];\n        },\n    };\n    const setter = camelize(`set ${property}`);\n    if (prototype[setter]) {\n        attributes.set = function (value) {\n            this[setter](value);\n        };\n    } else {\n        attributes.set = function (value) {\n            this.options[property] = value;\n        };\n    }\n    Object.defineProperty(prototype, property, attributes);\n})\n/**\n * @sort 1\n */\nclass InfiniteViewer extends EventEmitter<InfiniteViewerEvents> {\n    public options: InfiniteViewerOptions;\n    private injectResult!: InjectResult;\n    private wrapperElement!: HTMLElement;\n    private scrollAreaElement!: HTMLElement;\n    private horizontalScrollbar: ScrollBar;\n    private verticalScrollbar: ScrollBar;\n    private gesto!: Gesto;\n    private offsetX: number = 0;\n    private offsetY: number = 0;\n    private containerWidth: number = 0;\n    private containerHeight: number = 0;\n    private viewportWidth: number = 0;\n    private viewportHeight: number = 0;\n    private viewportScrollWidth: number = 0;\n    private viewportScrollHeight: number = 0;\n    private scrollLeft: number = 0;\n    private scrollTop: number = 0;\n    private _scrollTimer = 0;\n    private _zoomTimer = 0;\n\n    private _viewportElement: HTMLElement | null = null;\n    private _wheelContainerElement: HTMLElement | null = null;\n    private dragFlag: boolean = false;\n    private isLoop: boolean = false;\n    private _tempScale: number[] = [1, 1];\n    private _tempRect: { top: number, left: number, width: number, height: number } | null = null;\n    private _tempRectTimer: number | null = null;\n    private _onDestroys: Array<() => void> = [];\n    private _asLeft = 0;\n    private _asTop = 0;\n    /**\n     * @sort 1\n     */\n    constructor(\n        private _containerElement: HTMLElement,\n        viewportElement: HTMLElement | Partial<InfiniteViewerOptions> = {},\n        options: Partial<InfiniteViewerOptions> = {},\n    ) {\n        super();\n\n\n        if (viewportElement instanceof Element) {\n            this._viewportElement = viewportElement;\n            this.options = {\n                ...DEFAULT_OPTIONS,\n                ...options,\n            };\n        } else {\n            this._viewportElement = _containerElement.children[0] as HTMLElement;\n            this.options = {\n                ...DEFAULT_OPTIONS,\n                ...viewportElement,\n            };\n        }\n        this.init();\n    }\n    /**\n     * Get Container Element\n     */\n    public getContainer(): HTMLElement {\n        return this._containerElement;\n    }\n    /**\n     * Get Wheel Container Element\n     */\n    public getWheelContainer(): HTMLElement {\n        return this._wheelContainerElement;\n    }\n    /**\n     * Get Viewport Element\n     */\n    public getViewport(): HTMLElement {\n        return this._viewportElement;\n    }\n    /**\n     * Get Wrapper Element\n     */\n    public getWrapper(): HTMLElement {\n        return this.wrapperElement;\n    }\n    /**\n     * Get Scroll Area Element\n     */\n    public geScrollArea(): HTMLElement {\n        return this.scrollAreaElement;\n    }\n    /**\n     * Destroy elements, properties, and events.\n     */\n    public destroy(): void {\n        this.off();\n        this.gesto.unset();\n        this.verticalScrollbar.destroy();\n        this.horizontalScrollbar.destroy();\n        this.injectResult.destroy();\n        const containerElement = this._containerElement;\n\n        this._onDestroys.forEach(callback => {\n            callback();\n        });\n        removeEvent(this.wrapperElement, \"scroll\", this._onScroll);\n        removeEvent(this._wheelContainerElement, \"wheel\", this.onWheel);\n        removeEvent(containerElement, \"gesturestart\", this.onGestureStart);\n        removeEvent(containerElement, \"gesturechange\", this.onGestureChange);\n        removeEvent(containerElement, \"gesturesend\", this.onGestureEnd);\n\n        this.gesto = null;\n        this.injectResult = null;\n        this._containerElement = null;\n        this._viewportElement = null;\n        this.options = null;\n    }\n    /**\n     * Gets the number of pixels that an element's content is scrolled vertically.\n     */\n    public getScrollTop(options: GetScollPosOptions | boolean = {}) {\n        let range = false;\n        let absolute = false;\n\n        if (isObject(options)) {\n            range = options.range;\n            absolute = options.absolute;\n        } else {\n            range = options;\n        }\n        const zoom = this.zoomY;\n        const pos = this.scrollTop / zoom + this.offsetY\n            + (range ? abs(this.getRangeY()[0]) : 0);\n\n        return absolute ? pos * zoom : pos;\n    }\n    /**\n     * Gets the number of pixels that an element's content is scrolled vertically.\n     */\n    public getScrollLeft(options: GetScollPosOptions | boolean = {}) {\n        let range = false;\n        let absolute = false;\n\n        if (isObject(options)) {\n            range = options.range;\n            absolute = options.absolute;\n        } else {\n            range = options;\n        }\n        const zoom = this.zoomX;\n        const pos = this.scrollLeft / zoom + this.offsetX\n            + (range ? abs(this.getRangeX()[0]) : 0);\n\n        return absolute ? pos * zoom : pos;\n    }\n    /**\n     * Gets measurement of the width of an element's content with overflow\n     */\n    public getScrollWidth(isZoom?: boolean) {\n        const range = this._getScrollRangeX();\n        const zoom = this.zoomX;\n        const size = this.containerWidth / zoom + abs(range[0]) + range[1];\n\n        return isZoom ? size : size * zoom;\n    }\n    /**\n     * Gets measurement of the height of an element's content with overflow\n     */\n    public getScrollHeight(isZoom?: boolean) {\n        const range = this._getScrollRangeY();\n        const zoom = this.zoomY;\n        const size = this.containerHeight / zoom + abs(range[0]) + range[1];\n\n        return isZoom ? size : size * zoom;\n    }\n\n    /**\n     * Scroll the element to the center\n     */\n    public scrollCenter(options: ScrollCenterOptions = {}) {\n        this.resize();\n\n        const zoomX = this.zoomX;\n        const zoomY = this.zoomY;\n\n        let left = -(this.containerWidth / zoomX - this.viewportWidth) / 2;\n        let top = -(this.containerHeight / zoomY - this.viewportHeight) / 2;\n\n        if (options.absolute) {\n            left *= zoomX;\n            top *= zoomY;\n        }\n        if (options.horizontal === false) {\n            left = this.getScrollLeft();\n        }\n        if (options.vertical === false) {\n            top = this.getScrollTop();\n        }\n\n        return this.scrollTo(left, top, options);\n    }\n    /**\n     * Update Viewer Sizes\n     * @method\n     */\n    public resize = () => {\n        const {\n            offsetWidth: containerWidth,\n            offsetHeight: containerHeight,\n        } = this._containerElement;\n        const {\n            offsetWidth: viewportWidth,\n            offsetHeight: viewportHeight,\n            scrollWidth: viewportScrollWidth,\n            scrollHeight: viewportScrollHeight,\n        } = this._viewportElement;\n\n        this.containerWidth = containerWidth;\n        this.containerHeight = containerHeight;\n        this.viewportWidth = viewportWidth;\n        this.viewportHeight = viewportHeight;\n        this.viewportScrollWidth = Math.max(viewportWidth, viewportScrollWidth);\n        this.viewportScrollHeight = Math.max(viewportWidth, viewportScrollHeight);\n\n        this.render();\n        this._scrollBy(0, 0);\n    }\n    /**\n     * Move to that position or zoom.\n     * @since 0.25.0\n     */\n    public setTo(options: SetOptions) {\n        const {\n            x = this.getScrollLeft(),\n            y = this.getScrollTop(),\n            zoom = [this.getZoomX(), this.getZoomY()],\n            duration,\n        } = options;\n        const {\n            zoomX: prevZoomX,\n            zoomY: prevZoomY,\n            zoomRange,\n        } = this;\n        let {\n            zoomOffsetX = DEFAULT_OPTIONS.zoomOffsetX,\n            zoomOffsetY = DEFAULT_OPTIONS.zoomOffsetY,\n        } = this;\n        if (\"zoomOffsetX\" in options) {\n            zoomOffsetX = options.zoomOffsetX;\n        }\n        if (\"zoomOffsetY\" in options) {\n            zoomOffsetY = options.zoomOffsetY;\n        }\n\n        const [zoomX, zoomY] = isArray(zoom) ? zoom : [zoom, zoom];\n        const nextZoomX = between(zoomX, zoomRange[0], zoomRange[1]);\n        const nextZoomY = between(zoomY, zoomRange[0], zoomRange[1]);\n        const zoomXPos = convertUnitSize(`${zoomOffsetX}`, this.viewportWidth) * (1 / prevZoomX - 1 / nextZoomX);\n        const zoomYPos = convertUnitSize(`${zoomOffsetY}`, this.viewportHeight) * (1 / prevZoomY - 1 / nextZoomY);\n\n        this.scrollTo(x - zoomXPos, y - zoomYPos, {\n            duration,\n        });\n        this.setZoom(zoom, {\n            zoomOffsetX,\n            zoomOffsetY,\n            duration,\n            zoomBase: \"fixed\",\n        });\n    }\n    /**\n     * Move by the position or zoom delta value.\n     * @since 0.25.0\n     */\n    public setBy(options: SetOptions) {\n        const {\n            x = 0,\n            y = 0,\n            zoom = [0, 0],\n        } = options;\n        const [zoomX, zoomY] = isArray(zoom) ? zoom : [zoom, zoom];\n\n        this.setTo({\n            ...options,\n            x: this.getScrollLeft() + x,\n            y: this.getScrollTop() + y,\n            zoom: [this.zoomX + zoomX, this.zoomY + zoomY],\n        });\n    }\n    /**\n     * Scrolls the container by the given amount.\n     */\n    public scrollBy(deltaX: number, deltaY: number, options?: ScrollOptions) {\n        this._pauseScrollAnimation();\n        if (!options || !options.duration) {\n            let scrollLeft = this.getScrollLeft();\n            let scrollTop = this.getScrollTop();\n\n            if (options?.absolute) {\n                scrollLeft *= this.zoomX;\n                scrollTop *= this.zoomY;\n            }\n            return this._scrollTo(scrollLeft + deltaX, scrollTop + deltaY, options);\n        } else {\n            this._startScrollAnimation([deltaX, deltaY], options);\n            return true;\n        }\n    }\n    /**\n     * Scrolls the container to set of coordinates.\n     * @param scrollLeft\n     * @param scrollTop\n     */\n    public scrollTo(x: number, y: number, options?: ScrollOptions) {\n        this._pauseScrollAnimation();\n        if (!options || !options.duration) {\n            return this._scrollTo(x, y, options);\n        } else {\n            let scrollLeft = this.getScrollLeft();\n            let scrollTop = this.getScrollTop();\n\n            if (options?.absolute) {\n                scrollLeft *= this.zoomX;\n                scrollTop *= this.zoomY;\n            }\n            return this.scrollBy(x - scrollLeft, y - scrollTop, options);\n        }\n    }\n    /**\n     * Set viewer zoom by the given amount\n     */\n    public zoomBy(deltaZoom: number | number[], options?: ZoomOptions) {\n        this._pauseZoomAnimation();\n        const [deltaX, deltaY] = isArray(deltaZoom)\n        ? deltaZoom\n        : [deltaZoom, deltaZoom];\n\n        if (!options || !options.duration) {\n            this._setZoom([\n                this.zoomX + deltaX,\n                this.zoomY + deltaY,\n            ], options);\n        } else {\n            this._startZoomAnimation([deltaX, deltaY], options);\n        }\n    }\n    /**\n     * Set viewer zoom\n     */\n    public setZoom(zoom: number | number[], options?: ZoomOptions) {\n        this._pauseZoomAnimation();\n\n        if (!options || !options.duration) {\n            this._setZoom(zoom, options);\n        } else {\n            const [zoomX, zoomY] = isArray(zoom)\n            ? zoom\n            : [zoom, zoom];\n            this._startZoomAnimation([\n                zoomX - this.zoomX,\n                zoomY - this.zoomY,\n            ], options);\n        }\n    }\n    public getViewportWidth() {\n        return this.viewportWidth;\n    }\n    public getViewportHeight() {\n        return this.viewportWidth;\n    }\n    public getViewportScrollWidth() {\n        return this.viewportScrollWidth;\n    }\n    public getViewportScrollHeight() {\n        return this.viewportScrollHeight;\n    }\n    public getContainerWidth() {\n        return this.containerWidth;\n    }\n    public getContainerHeight() {\n        return this.containerHeight;\n    }\n    /**\n     * Get viewer zoom\n     */\n    public getZoom() {\n        return (this.zoomX + this.zoomY) / 2;\n    }\n    /**\n     * Get viewer zoomX\n     * @since 0.20.0\n     */\n    public getZoomX() {\n        return this.zoomX;\n    }\n    /**\n     * Get viewer zoom\n     * @since 0.20.0\n     */\n    public getZoomY() {\n        return this.zoomY;\n    }\n    /**\n     * get x ranges\n     */\n    public getRangeX(isZoom?: boolean, isReal?: boolean) {\n        return this._getRangeCoord(\"horizontal\", isZoom, isReal);\n    }\n    /**\n     * get y ranges\n     */\n    public getRangeY(isZoom?: boolean, isReal?: boolean) {\n        return this._getRangeCoord(\"vertical\", isZoom, isReal);\n    }\n\n    private init() {\n        // infinite-viewer(container)\n        // viewportㅌ\n        // children\n        const containerElement = this._containerElement;\n        const options = this.options;\n\n        // vanilla\n        let wrapperElement = options.wrapperElement\n            || containerElement.querySelector(`.${WRAPPER_CLASS_NAME}`);\n        let scrollAreaElement = options.scrollAreaElement\n            || containerElement.querySelector(`.${SCROLL_AREA_CLASS_NAME}`);\n        const horizontalScrollElement = options.horizontalScrollElement\n            || containerElement.querySelector(`.${HORIZONTAL_SCROLL_BAR_CLASS_NAME}`);\n        const verticalScrollElement = options.verticalScrollElement\n            || containerElement.querySelector(`.${VERTICAL_SCROLL_BAR_CLASS_NAME}`);\n\n        if (!wrapperElement) {\n            wrapperElement = document.createElement(\"div\");\n            wrapperElement.insertBefore(this._viewportElement, null);\n            containerElement.insertBefore(wrapperElement, null);\n        }\n        this.wrapperElement = wrapperElement;\n\n        if (!scrollAreaElement) {\n            scrollAreaElement = document.createElement(\"div\");\n\n            wrapperElement.insertBefore(scrollAreaElement, wrapperElement.firstChild);\n        }\n        this.scrollAreaElement = scrollAreaElement;\n\n        addClass(containerElement, CLASS_NAME);\n        addClass(wrapperElement, WRAPPER_CLASS_NAME);\n        // addClass(restrictElement, RESTRICT_WRAPPER_CLASS_NAME);\n        addClass(scrollAreaElement, SCROLL_AREA_CLASS_NAME);\n\n        if (options.useBounceScrollBar) {\n            const horizontalBar = new BounceScrollBar(\n                \"horizontal\",\n                horizontalScrollElement,\n            );\n            const verticalBar = new BounceScrollBar(\n                \"vertical\",\n                verticalScrollElement,\n            );\n\n            horizontalBar.render = () => {\n                const {\n                    containerWidth,\n                    zoomX,\n                } = this;\n                const scrollPos = this.getScrollLeft(true) * zoomX;\n                const range = this.getRangeX(true);\n                const scrollSize =  containerWidth + abs(range[0]) + abs(range[1]);\n\n                horizontalBar.renderBounce(\n                    this.displayHorizontalScroll,\n                    scrollPos,\n                    containerWidth,\n                    scrollSize,\n                );\n            };\n            verticalBar.render = () => {\n                const {\n                    containerHeight,\n                    zoomY,\n                } = this;\n                const scrollPos = this.getScrollTop(true) * zoomY;\n                const range = this.getRangeY(true);\n                const scrollSize =  containerHeight + abs(range[0]) + abs(range[1]);\n\n                verticalBar.renderBounce(\n                    this.displayVerticalScroll,\n                    scrollPos,\n                    containerHeight,\n                    scrollSize,\n                );\n            };\n            this.horizontalScrollbar = horizontalBar;\n            this.verticalScrollbar = verticalBar;\n        } else {\n            const horizontalBar = new ScrollBar(\n                \"horizontal\",\n                horizontalScrollElement,\n            );\n            const verticalBar = new ScrollBar(\n                \"vertical\",\n                verticalScrollElement,\n            );\n\n            horizontalBar.render = () => {\n                const {\n                    containerWidth,\n                    zoomX,\n                } = this;\n\n                horizontalBar.renderDefault(\n                    this.displayHorizontalScroll,\n                    containerWidth / zoomX,\n                    this._getScrollRangeX(),\n                );\n            };\n            verticalBar.render = () => {\n                const {\n                    containerHeight,\n                    zoomY,\n                } = this;\n\n                verticalBar.renderDefault(\n                    this.displayVerticalScroll,\n                    containerHeight / zoomY,\n                    this._getScrollRangeY(),\n                );\n            };\n            this.horizontalScrollbar = horizontalBar;\n            this.verticalScrollbar = verticalBar;\n        }\n\n        this.horizontalScrollbar.on(\"scroll\", e => {\n            this.scrollBy(e.delta / this.zoomX, 0);\n        });\n\n        this.verticalScrollbar.on(\"scroll\", e => {\n            this.scrollBy(0, e.delta / this.zoomY);\n        });\n\n        if (this.horizontalScrollbar.isAppend) {\n            containerElement.insertBefore(this.horizontalScrollbar.barElement, null);\n        }\n        if (this.verticalScrollbar.isAppend) {\n            containerElement.insertBefore(this.verticalScrollbar.barElement, null);\n        }\n        this.injectResult = injector.inject(containerElement, {\n            nonce: this.options.cspNonce,\n        });\n\n        const wheelContainerOption = options.wheelContainer;\n        let wheelContainerElement: HTMLElement | null = null;\n\n        if (wheelContainerOption) {\n            if (isString(wheelContainerOption)) {\n                wheelContainerElement = document.querySelector(wheelContainerOption);\n            } else if (wheelContainerOption instanceof Node) {\n                wheelContainerElement = wheelContainerOption;\n            } else if (\"value\" in wheelContainerOption || \"current\" in wheelContainerOption) {\n                wheelContainerElement = wheelContainerOption.current || wheelContainerOption.value;\n            }\n        }\n        wheelContainerElement ||= containerElement;\n        this._wheelContainerElement = wheelContainerElement;\n\n        /**\n         * the `dragStart` event fires when `touchstart` does occur.\n         * @memberof InfiniteViewer\n         * @event dragStart\n         * @param {InfiniteViewer.OnDragStart} - Parameters for the `dragStart` event\n         * @example\n         * import InfiniteViewer from \"infinite-viewer\";\n         *\n         * const viewer = new InfiniteViewer(\n         *   document.querySelector(\".container\"),\n         *   document.querySelector(\".viewport\"),\n         * ).on(\"dragStart\", e => {\n         *   console.log(e.inputEvent);\n         * });\n         */\n        /**\n         * the `drag` event fires when `touch` does occur.\n         * @memberof InfiniteViewer\n         * @event drag\n         * @param {InfiniteViewer.OnDrag} - Parameters for the `drag` event\n         * @example\n         * import InfiniteViewer from \"infinite-viewer\";\n         *\n         * const viewer = new InfiniteViewer(\n         *   document.querySelector(\".container\"),\n         *   document.querySelector(\".viewport\"),\n         * ).on(\"drag\", e => {\n         *   console.log(e.inputEvent);\n         * });\n         */\n        /**\n         * the `dragEnd` event fires when `touchend` does occur.\n         * @memberof InfiniteViewer\n         * @event dragEnd\n         * @param {InfiniteViewer.OnDragEnd} - Parameters for the `dragEnd` event\n         * @example\n         * import InfiniteViewer from \"infinite-viewer\";\n         *\n         * const viewer = new InfiniteViewer(\n         *   document.querySelector(\".container\"),\n         *   document.querySelector(\".viewport\"),\n         * ).on(\"dragEnd\", e => {\n         *   console.log(e.inputEvent);\n         * });\n         */\n        /**\n         * the `abortPinch` event fires when `pinch` event does not occur by dragging a certain area.\n         * @memberof InfiniteViewer\n         * @event abortPinch\n         * @param {InfiniteViewer.OnAbortPinch} - Parameters for the abortPinch event\n         * @example\n         * import InfiniteViewer from \"infinite-viewer\";\n         *\n         * const viewer = new InfiniteViewer(\n         *   document.querySelector(\".container\"),\n         *   document.querySelector(\".viewport\"),\n         *   {\n         *     usePinch: true,\n         *   }\n         * ).on(\"abortPinch\", e => {\n         *   console.log(e.inputEvent);\n         * });\n         */\n        /**\n         * the `pinch` event fires when two points pinch the viewer\n         * The pinchStart and abortPinch events do not occur when pinching through the wheel.\n         * @memberof InfiniteViewer\n         * @event pinch\n         * @param {InfiniteViewer.OnPinch} - Parameters for the `pinch` event\n         * @example\n         * import InfiniteViewer from \"infinite-viewer\";\n         *\n         * const viewer = new InfiniteViewer(\n         *   document.querySelector(\".container\"),\n         *   document.querySelector(\".viewport\"),\n         *   {\n         *     usePinch: true,\n         *   }\n         * ).on(\"pinch\", e => {\n         *   console.log(e.zoom, e.inputEvent);\n         * });\n         */\n        this.gesto = new Gesto(containerElement, {\n            container: window,\n            events: [\"touch\", \"mouse\"],\n            preventWheelClick: this.options.preventWheelClick ?? true,\n        }).on(\"dragStart\", e => {\n            const {\n                inputEvent,\n                stop,\n                datas,\n            } = e;\n            if (!this.useMouseDrag && e.isMouseEvent) {\n                stop();\n                return;\n            }\n            this._pauseScrollAnimation();\n            this.dragFlag = false;\n            const result = this.trigger(\"dragStart\", e);\n\n            if (result === false) {\n                stop();\n                return;\n            }\n            inputEvent.preventDefault();\n            datas.startEvent = inputEvent;\n        }).on(\"drag\", e => {\n            if (!this.options.usePinch || e.isPinch || (this.useMouseDrag && e.isMouseEvent)) {\n                this.trigger(\"drag\", {\n                    ...e,\n                    inputEvent: e.inputEvent,\n                });\n                measureSpeed(e);\n                this.scrollBy(-e.deltaX / this.zoomX, -e.deltaY / this.zoomY);\n            } else if (!this.dragFlag && e.movement > options.pinchThreshold) {\n                this.dragFlag = true;\n\n                this.trigger(\"abortPinch\", {\n                    inputEvent: e.datas.startEvent || e.inputEvent,\n                });\n            }\n        }).on(\"dragEnd\", e => {\n            this.trigger(\"dragEnd\", {\n                isDrag: e.isDrag,\n                isDouble: e.isDouble,\n                inputEvent: e.inputEvent,\n            });\n            this._startScrollAnimationBySpeed(e.datas.speed);\n        }).on(\"pinchStart\", ({ inputEvent, datas, stop }) => {\n            inputEvent.preventDefault();\n            this._pauseScrollAnimation();\n            datas.startZoom = [this.zoomX, this.zoomY];\n\n            const result = this.trigger(\"pinchStart\", {\n                inputEvent,\n            });\n            if (result === false) {\n                stop();\n            }\n            this._setClientRect();\n        }).on(\"pinch\", e => {\n            const scale = e.scale;\n            const pinchDirection = this.options.pinchDirection;\n\n            this._triggerPinch({\n                rotation: e.rotation,\n                distance: e.distance,\n                scale: e.scale,\n                inputEvent: e.inputEvent,\n                isWheel: false,\n                zoom: e.datas.startZoom * scale,\n                zoomX: this.zoomX * (pinchDirection === \"vertical\" ? 1 : scale),\n                zoomY: this.zoomY * (pinchDirection === \"horizontal\" ? 1 : scale),\n                clientX: e.clientX,\n                clientY: e.clientY,\n                ratioX: 0,\n                ratioY: 0,\n            });\n        }).on(\"pinchEnd\", () => {\n            this._tempRect = null;\n        });\n\n        addEvent(wrapperElement, \"scroll\", this._onScroll);\n\n        if (options.useResizeObserver) {\n            const observer = new ResizeObserver(() => {\n                this.resize();\n            });\n\n            observer.observe(this._viewportElement);\n            observer.observe(this._containerElement);\n\n\n            this._onDestroys.push(() => {\n                observer.disconnect();\n            });\n        } else {\n            addEvent(window, \"resize\", this.resize);\n\n            this._onDestroys.push(() => {\n                removeEvent(window, \"resize\", this.resize);\n            })\n        }\n\n        if (options.useWheelPinch || options.useWheelScroll) {\n            addEvent(wheelContainerElement, \"wheel\", this.onWheel, {\n                passive: false,\n            });\n        }\n        if (options.useGesture) {\n            addEvent(containerElement, \"gesturestart\", this.onGestureStart, {\n                passive: false,\n            });\n            addEvent(containerElement, \"gesturechange\", this.onGestureChange, {\n                passive: false,\n            });\n        }\n        this.resize();\n    }\n    private render() {\n        const {\n            offsetX,\n            offsetY,\n            zoomX = DEFAULT_OPTIONS.zoomX,\n            zoomY = DEFAULT_OPTIONS.zoomY,\n            translateZ = 0,\n            rangeX,\n            rangeY,\n            containerWidth,\n            containerHeight,\n        } = this;\n        const {\n            useTransform = DEFAULT_OPTIONS.useTransform,\n        } = this.options;\n        let nextOffsetX = -offsetX * zoomX;\n        let nextOffsetY = -offsetY * zoomY;\n\n        this.scrollAreaElement.style.cssText\n            = `width:calc(100% + ${this.getScrollAreaWidth()}px);`\n            + `height:calc(100% + ${this.getScrollAreaHeight()}px);`;\n\n        const viewportStyle = this._viewportElement.style;\n\n        if (useTransform === false) {\n            viewportStyle.cssText += `position: relative; left: ${nextOffsetX}px; top: ${nextOffsetY}px; `;\n\n            // if (restrictOffsetX || restrictOffsetY) {\n            //     viewportStyle.cssText += `position: relative; left: ${restrictOffsetX}px; top: ${restrictOffsetY}px`;\n            // }\n        } else {\n            viewportStyle.cssText += `transform-origin: 0 0;`\n                + `transform:translate3d(${nextOffsetX}px, ${nextOffsetY}px, ${translateZ}px) scale(${zoomX}, ${zoomY});`;\n\n            // if (restrictOffsetX || restrictOffsetY) {\n            //     viewportStyle.cssText += `transform:translate3d(${restrictOffsetX}px, ${restrictOffsetY}px, 0px)`;\n            // }\n        }\n        this.renderScroll();\n    }\n    private renderScroll() {\n        this.horizontalScrollbar.render();\n        this.verticalScrollbar.render();\n    }\n    private move(scrollLeft: number, scrollTop: number) {\n        const wrapperElement = this.wrapperElement;\n\n        wrapperElement.scrollLeft = scrollLeft;\n        wrapperElement.scrollTop = scrollTop;\n    }\n    private _onScroll = () => {\n        const { scrollLeft, scrollTop } = this.wrapperElement;\n        const {\n            zoom = DEFAULT_OPTIONS.zoom,\n        } = this;\n        const deltaX = scrollLeft - this.scrollLeft;\n        const deltaY = scrollTop - this.scrollTop;\n        const viewerScrollLeft = this.getScrollLeft();\n        const viewerScrollTop = this.getScrollTop();\n\n        if (this.isLoop) {\n            this.isLoop = false;\n        }\n        this.scrollLeft = scrollLeft;\n        this.scrollTop = scrollTop;\n        this.scrollTo(\n            viewerScrollLeft + deltaX / zoom,\n            viewerScrollTop + deltaY / zoom,\n        );\n    }\n    private onWheel = (e: WheelEvent) => {\n        const options = this.options;\n        const pinchDirection = options.pinchDirection;\n        const maxPinchWheel = options.maxPinchWheel || Infinity;\n\n        const isKeydown = e[`${this.wheelPinchKey}Key`] || e.ctrlKey;\n\n        if (options.useWheelPinch && isKeydown) {\n            let deltaY = e.deltaY;\n            const sign = deltaY >= 0 ? 1 : -1;\n            const distance = Math.min(maxPinchWheel, Math.abs(deltaY));\n\n\n            deltaY = sign * distance;\n            const delta = -deltaY;\n            const scale = Math.max(1 + delta * (options.wheelScale || 0.01), TINY_NUM);\n\n            clearTimeout(this._tempRectTimer);\n            this._tempRectTimer = window.setTimeout(() => {\n                this._tempRect = null;\n            }, 100);\n            this._triggerPinch({\n                distance,\n                scale,\n                rotation: 0,\n                zoom: this.zoom * scale,\n                zoomX: this.zoomX * (pinchDirection === \"vertical\" ? 1 : scale),\n                zoomY: this.zoomY * (pinchDirection === \"horizontal\" ? 1 : scale),\n                inputEvent: e,\n                isWheel: true,\n                clientX: e.clientX,\n                clientY: e.clientY,\n                ratioX: 0,\n                ratioY: 0,\n            });\n        } else if (options.useWheelScroll) {\n            let deltaX = e.deltaX;\n            let deltaY = e.deltaY;\n\n            if (e.shiftKey && !deltaX) {\n                deltaX = deltaY;\n                deltaY = 0;\n            }\n            this.scrollBy(deltaX / this.zoomX, deltaY / this.zoomY);\n        } else {\n            return;\n        }\n        e.preventDefault();\n    }\n    private onGestureStart = (e: any) => {\n        this._tempScale = [this.zoomX, this.zoomY];\n        this._setClientRect();\n        e.preventDefault();\n    }\n    private onGestureChange = (e: any) => {\n        e.preventDefault();\n        if (this.gesto.isFlag() || !this._tempScale) {\n            this._tempScale =  [1, 1];\n            return;\n        }\n        const scale = e.scale;\n        const zoomX = this._tempScale[0];\n        const zoomY = this._tempScale[1];\n        const pinchDirection = this.options.pinchDirection;\n\n        this._triggerPinch({\n            distance: 0,\n            scale,\n            rotation: e.rotation,\n            inputEvent: e,\n            isWheel: true,\n            zoom: (zoomX + zoomY) * scale / 2,\n            zoomX: zoomX * (pinchDirection === \"vertical\" ? 1 : scale),\n            zoomY: zoomY * (pinchDirection === \"horizontal\" ? 1 : scale),\n            clientX: e.clientX,\n            clientY: e.clientY,\n            ratioX: 0,\n            ratioY: 0,\n        });\n    }\n    private onGestureEnd = () => {\n\n    }\n    private _startZoomAnimation(dest: number[], options: ZoomOptions) {\n        if (!dest) {\n            return;\n        }\n        const duration = options.duration;\n        const easing = options.easing || DEFAULT_EASING;\n\n        startAnimation(\n            distRatio => this._setZoom(\n                [\n                    this.zoomX + dest[0] * distRatio,\n                    this.zoomY + dest[1] * distRatio,\n                ],\n                options,\n            ),\n            next => {\n                this._zoomTimer = requestAnimationFrame(next);\n            },\n            {\n                easing,\n                duration,\n            },\n        );\n    }\n    private _startScrollAnimation(dest: number[], options: AnimationOptions) {\n        if (!dest[0] && !dest[1]) {\n            return;\n        }\n        const duration = options.duration;\n        const easing = options.easing || DEFAULT_EASING;\n\n        startAnimation(\n            distRatio => this._scrollBy(\n                dest[0] * distRatio,\n                dest[1] * distRatio,\n                options,\n            ),\n            next => {\n                this._scrollTimer = requestAnimationFrame(next);\n            },\n            {\n                easing,\n                duration,\n            },\n        );\n    }\n    private _startScrollAnimationBySpeed(speed: number[]) {\n        if (!speed || (!speed[0] && !speed[1])) {\n            return;\n        }\n        const a = -0.0006;\n        const duration = getDuration(speed, a);\n        const destPos = getDestPos(speed, a);\n\n        return this._startScrollAnimation(destPos, {\n            duration,\n        })\n\n    }\n    private _pauseScrollAnimation() {\n        cancelAnimationFrame(this._scrollTimer);\n        this._scrollTimer = 0;\n    }\n    private _pauseZoomAnimation() {\n        cancelAnimationFrame(this._zoomTimer);\n        this._zoomTimer = 0;\n    }\n    private getScrollAreaWidth() {\n        const [min, max] = this.getRangeX(true);\n        return min || max ? this.margin * 2 : 0;\n    }\n    private getScrollAreaHeight() {\n        const [min, max] = this.getRangeY(true);\n        return min || max ? this.margin * 2 : 0;\n    }\n    private _triggerPinch(event: OnPinch) {\n        const {\n            clientX,\n            clientY,\n            zoomX,\n            zoomY,\n        } = event;\n        if (this.useAutoZoom) {\n            this._zoomByClient([zoomX, zoomY], clientX, clientY);\n        }\n        if (!this._tempRect) {\n            this._setClientRect();\n        }\n        const zoomRange = this.zoomRange;\n        const {\n            left,\n            top,\n            width,\n            height,\n        } = this._tempRect;\n        const ratioX = (clientX - left) / width * 100;\n        const ratioY = (clientY - top) / height * 100;\n\n        this.trigger(\"pinch\", {\n            ...event,\n            zoom: between((zoomX + zoomY) / 2, zoomRange[0], zoomRange[1]),\n            zoomX: between(zoomX, zoomRange[0], zoomRange[1]),\n            zoomY: between(zoomY, zoomRange[0], zoomRange[1]),\n            ratioX,\n            ratioY,\n        });\n    }\n    private _setClientRect() {\n        const rect = this.getContainer().getBoundingClientRect();\n        this._tempRect = {\n            left: rect.left,\n            top: rect.top,\n            width: rect.width,\n            height: rect.height,\n        };\n    }\n    private _zoomByClient(zoom: number[], clientX: number, clientY: number) {\n        if (!this._tempRect) {\n            this._setClientRect();\n        }\n        const {\n            left,\n            top,\n            width,\n            height,\n        } = this._tempRect;\n        const options = this.options;;\n\n        const originalZoomOffsetX = options.zoomOffsetX;\n        const originalZoomOffsetY = options.zoomOffsetY;\n\n        options.zoomOffsetX = `${(clientX - left) / width * 100}%`;\n        options.zoomOffsetY = `${(clientY - top) / height * 100}%`;\n\n        this._setZoom(zoom, {\n            zoomBase: \"screen\",\n        });\n\n        options.zoomOffsetX = originalZoomOffsetX;\n        options.zoomOffsetY = originalZoomOffsetY;\n    }\n    private _setZoom(\n        zoom: number | number[],\n        zoomOptions: ZoomOptions = {},\n    ) {\n        const zoomBase = zoomOptions.zoomBase;\n        const {\n            containerWidth,\n            containerHeight,\n            zoomX: prevZoomX,\n            zoomY: prevZoomY,\n            zoomRange\n        } = this;\n        let {\n            zoomOffsetX = DEFAULT_OPTIONS.zoomOffsetX,\n            zoomOffsetY = DEFAULT_OPTIONS.zoomOffsetY,\n        } = this;\n        if (\"zoomOffsetX\" in zoomOptions) {\n            zoomOffsetX = zoomOptions.zoomOffsetX;\n        }\n        if (\"zoomOffsetY\" in zoomOptions) {\n            zoomOffsetY = zoomOptions.zoomOffsetY;\n        }\n\n        const scrollLeft = this.getScrollLeft();\n        const scrollTop = this.getScrollTop();\n\n        const [zoomX, zoomY] = isArray(zoom) ? zoom : [zoom, zoom];\n        const nextZoomX = between(zoomX, zoomRange[0], zoomRange[1]);\n        const nextZoomY = between(zoomY, zoomRange[0], zoomRange[1]);\n        const options = this.options;\n\n        options.zoomX = nextZoomX;\n        options.zoomY = nextZoomY;\n        options.zoom = (nextZoomX + nextZoomY) / 2;\n\n        const nextScrollLeft = this.getScrollLeft();\n        const nextScrollTop = this.getScrollTop();\n\n\n        let zoomXPos = 0;\n        let zoomYPos = 0;\n\n        if (zoomBase === \"fixed\") {\n            zoomXPos = convertUnitSize(`${zoomOffsetX}`, this.viewportWidth);\n            zoomYPos = convertUnitSize(`${zoomOffsetY}`, this.viewportHeight);\n        } else if (zoomBase === \"viewport\") {\n            zoomXPos = (-scrollLeft + convertUnitSize(`${zoomOffsetX}`, this.viewportWidth)) * prevZoomX;\n            zoomYPos = (-scrollTop + convertUnitSize(`${zoomOffsetY}`, this.viewportHeight)) * prevZoomY;\n        } else {\n            zoomXPos = convertUnitSize(`${zoomOffsetX}`, containerWidth);\n            zoomYPos = convertUnitSize(`${zoomOffsetY}`, containerHeight);\n        }\n\n        const centerX = scrollLeft + zoomXPos / prevZoomX;\n        const centerY = scrollTop + zoomYPos / prevZoomY;\n\n        const nextCenterX = nextScrollLeft + zoomXPos / nextZoomX;\n        const nextCenterY = nextScrollTop + zoomYPos / nextZoomY;\n\n        this._scrollBy(\n            centerX - nextCenterX,\n            centerY - nextCenterY,\n            {\n                zoom: !!(nextZoomX - prevZoomX || nextZoomY - prevZoomY),\n            },\n        );\n        this.render();\n    }\n    private _scrollBy(deltaX: number, deltaY: number, options?: InnerScrollOptions) {\n        let scrollLeft = this.getScrollLeft();\n        let scrollTop = this.getScrollTop();\n\n        if (options?.absolute) {\n            scrollLeft *= this.zoomX;\n            scrollTop *= this.zoomY;\n        }\n        return this._scrollTo(scrollLeft + deltaX, scrollTop + deltaY, options);\n    }\n    private _scrollTo(x: number, y: number, options?: InnerScrollOptions) {\n        const {\n            scrollLeft: prevScrollLeft,\n            scrollTop: prevScrollTop,\n        } = this;\n\n        const isAbsolute = options?.absolute;\n        this._scrollToType(\"horizontal\", x, isAbsolute);\n        this._scrollToType(\"vertical\", y, isAbsolute);\n\n        const scrollLeft = this.scrollLeft;\n        const scrollTop = this.scrollTop;\n        this.render();\n        const nextScrollAbsoluteLeft = this.getScrollLeft();\n        const nextScrollAbsoluteTop = this.getScrollTop();\n\n        this._emitScrollEvent(nextScrollAbsoluteLeft, nextScrollAbsoluteTop, options?.zoom);\n\n        if (Math.round(prevScrollLeft) !== scrollLeft || Math.round(prevScrollTop) !== scrollTop) {\n            this.isLoop = true;\n            this.move(scrollLeft, scrollTop);\n            requestAnimationFrame(() => {\n                if (!this.isLoop) {\n                    return;\n                }\n                this.isLoop = false;\n                const {\n                    scrollLeft: requestScrollLeft,\n                    scrollTop: requestScrollTop,\n                } = this.wrapperElement;\n\n                this.scrollLeft = requestScrollLeft;\n                this.scrollTop = requestScrollTop;\n\n                if (\n                    scrollLeft !== Math.round(requestScrollLeft)\n                    || scrollTop !== Math.round(requestScrollTop)\n                ) {\n                    this._scrollTo(nextScrollAbsoluteLeft, nextScrollAbsoluteTop);\n                }\n            });\n            return false;\n        }\n        return true;\n    }\n    private _scrollToType(type: \"horizontal\" | \"vertical\", coord: number, isAbsolute?: boolean) {\n        const names = NAMES[type];\n        const {\n            margin = DEFAULT_OPTIONS.margin,\n            threshold = DEFAULT_OPTIONS.threshold,\n        } = this;\n        const prevScrollPos = this[`scroll${names.pos}`];\n        const [minCoord, maxCoord] = this[`getRange${names.coord}`](true, true);\n\n        let scrollPos = Math.round(prevScrollPos);\n\n        const scrollAreaSize = this[`getScrollArea${names.size}`]();\n        const zoom = this[`zoom${names.coord}`];\n\n        if (isAbsolute) {\n            coord = coord / zoom;\n        }\n        const zoomCoord = coord * zoom;\n\n        if (minCoord === maxCoord) {\n            scrollPos = minCoord;\n            coord = minCoord / zoom;\n        } else if (zoomCoord - threshold <= minCoord) {\n            const minThreshold = Math.max(0, zoomCoord - minCoord);\n\n            scrollPos = minThreshold;\n            coord = (minCoord + minThreshold) / zoom;\n        } else if (zoomCoord + threshold >= maxCoord) {\n            const maxThreshold = Math.max(0, maxCoord - zoomCoord);\n\n            scrollPos = scrollAreaSize - maxThreshold;\n            coord = (maxCoord - maxThreshold) / zoom;\n        } else if (scrollPos < threshold) {\n            scrollPos += margin;\n        } else if (scrollPos > scrollAreaSize - threshold) {\n            scrollPos -= margin;\n        }\n\n        scrollPos = Math.round(scrollPos);\n\n        this[`scroll${names.pos}`] = scrollPos;\n        this[`offset${names.coord}`] = coord - scrollPos / zoom;\n    }\n    private _getRangeCoord(type: \"vertical\" | \"horizontal\", isZoom?: boolean, isReal?: boolean) {\n        const {\n            margin = DEFAULT_OPTIONS.margin,\n            threshold,\n        } = this;\n\n        const names = NAMES[type];\n        const rangeCoord = checkDefault(\n            this[`range${names.coord}`],\n            DEFAULT_OPTIONS[`range${names.coord}`],\n        );\n        const rangeOffsetCoord = checkDefault(\n            this[`rangeOffset${names.coord}`],\n            DEFAULT_OPTIONS[`rangeOffset${names.coord}`],\n        );\n        const zoom = this[`zoom${names.coord}`];\n        const range = getRange(\n            this[`getScroll${names.pos}`](),\n            margin,\n            rangeCoord,\n            threshold,\n            isReal,\n        );\n\n        if (!isZoom) {\n            return [\n                range[0] + rangeOffsetCoord[0],\n                range[1] + rangeOffsetCoord[1],\n            ];\n        }\n        return [\n            range[0] * zoom + rangeOffsetCoord[0],\n            range[1] * zoom + rangeOffsetCoord[1],\n            // Math.max(this[`viewport${names.size}`] * zoom - this[`container${names.size}`], range[1] * zoom + rangeOffsetCoord[1]),\n        ];\n    }\n    private _emitScrollEvent(scrollLeft: number, scrollTop: number, zoom?: boolean) {\n        const prevScrollLeft = this._asLeft;\n        const prevScrollTop = this._asTop;\n\n        if (!zoom && prevScrollLeft === scrollLeft && prevScrollTop === scrollTop) {\n            return;\n        }\n        this._asLeft = scrollLeft;\n        this._asTop = scrollTop;\n\n        /**\n         * The `scroll` event fires when the document view or an element has been scrolled.\n         * @memberof InfiniteViewer\n         * @event scroll\n         * @param {InfiniteViewer.OnScroll} - Parameters for the scroll event\n         * @example\n         * import InfiniteViewer from \"infinite-viewer\";\n         *\n         * const viewer = new InfiniteViewer(\n         *   document.querySelector(\".container\"),\n         *   document.querySelector(\".viewport\"),\n         * ).on(\"scroll\", () => {\n         *   console.log(viewer.getScrollLeft(), viewer.getScrollTop());\n         * });\n         */\n        this.trigger(\"scroll\", {\n            scrollLeft,\n            scrollTop,\n            zoomX: this.zoomX,\n            zoomY: this.zoomY,\n        });\n    }\n    private _getScrollRangeX() {\n        const pos = this.getScrollLeft();\n        const startMargin =  Math.min(0, pos);\n        const endMargin = Math.max(0, pos);\n        const viewportSize = this.viewportScrollWidth;\n        const margin = Math.max(this.containerWidth / this.zoomX, viewportSize) - viewportSize;\n        const startSizeOffset = Math.min(0, margin + startMargin);\n\n        return [\n            startSizeOffset,\n            endMargin,\n        ];\n    }\n    private _getScrollRangeY() {\n        const pos = this.getScrollTop();\n        const startMargin =  Math.min(0, pos);\n        const endMargin = Math.max(0, pos);\n        const viewportSize = this.viewportScrollHeight;\n        const margin = Math.max(this.containerHeight / this.zoomY, viewportSize) - viewportSize;\n        const startSizeOffset = Math.min(0, margin + startMargin);\n\n        return [\n            startSizeOffset,\n            endMargin,\n        ];\n    }\n}\n\ninterface InfiniteViewer extends InfiniteViewerProperties { }\n\nexport default InfiniteViewer;\n"],"names":["DEFAULT_EASING","x","Math","pow","IS_SAFARI","browser","name","PREFIX","WRAPPER_CLASS_NAME","SCROLL_AREA_CLASS_NAME","SCROLL_BAR_CLASS_NAME","HORIZONTAL_SCROLL_BAR_CLASS_NAME","VERTICAL_SCROLL_BAR_CLASS_NAME","SCROLL_THUMB_CLASS_NAME","injector","DEFAULT_OPTIONS","margin","threshold","zoom","zoomX","zoomY","rangeX","Infinity","rangeY","rangeOffsetX","rangeOffsetY","wrapperElement","scrollAreaElement","horizontalScrollElement","verticalScrollElement","usePinch","useAutoZoom","useMouseDrag","pinchThreshold","cspNonce","maxPinchWheel","wheelScale","displayHorizontalScroll","displayVerticalScroll","useTransform","useWheelPinch","zoomRange","wheelPinchKey","useWheelScroll","zoomOffsetX","zoomOffsetY","translateZ","useGesture","useResizeObserver","pinchDirection","preventWheelClick","useBounceScrollBar","NAMES","horizontal","pos","coord","size","vertical","CLASS_NAME","className","PROPERTIES","OPTIONS","__spreadArray","getDuration","speed","a","normalSpeed","sqrt","abs","v","checkDefault","value","defaultValue","startAnimation","callback","timerCallback","options","next","now","Date","t","startTime","ratio","easing","duration","prevRatio","prevTime","type","container","thumbElement","_super","isHorizontal","_this","e","target","inputEvent","datas","isThumb","setTimeout","requestAnimationFrame","thumbRect","getBoundingClientRect","pos1","thumbSize","clientPos","endPos","startPos","delta","scrollSize","scrollBy","stopPropagation","preventDefault","deltaX","deltaY","trigger","barElement","querySelector","document","createElement","insertBefore","isAppend","addClass","gesto","Gesto","window","on","_onDragStart","_onDrag","addEvent","_onWheel","passive","__extends","__proto","isAbsolute","this","isDisplay","containerSize","scrollRange","startMargin","endMargin","scrollSizeOffset","opacity","_a","dirName1","sizeName","thumbPos","style","cssText","removeEvent","off","EventEmitter","pos2","ScrollBar","_containerElement","viewportElement","containerWidth","containerHeight","_b","_viewportElement","viewportWidth","viewportHeight","viewportScrollWidth","viewportScrollHeight","max","render","_scrollBy","scrollLeft","scrollTop","viewerScrollLeft","getScrollLeft","viewerScrollTop","getScrollTop","isLoop","scrollTo","isKeydown","ctrlKey","sign","distance","min","scale","clearTimeout","_tempRectTimer","_tempRect","_triggerPinch","rotation","isWheel","clientX","clientY","ratioX","ratioY","shiftKey","_tempScale","_setClientRect","isFlag","Element","children","init","_wheelContainerElement","unset","verticalScrollbar","destroy","horizontalScrollbar","injectResult","containerElement","_onDestroys","forEach","_onScroll","onWheel","onGestureStart","onGestureChange","onGestureEnd","range","absolute","isObject","offsetY","getRangeY","offsetX","getRangeX","isZoom","_getScrollRangeX","_getScrollRangeY","resize","left","top","y","_c","getZoomX","getZoomY","prevZoomX","prevZoomY","_f","_g","_h","isArray","nextZoomX","between","nextZoomY","zoomXPos","convertUnitSize","zoomYPos","setZoom","zoomBase","_d","setTo","_pauseScrollAnimation","_startScrollAnimation","_scrollTo","deltaZoom","_pauseZoomAnimation","_startZoomAnimation","_setZoom","isReal","_getRangeCoord","horizontalBar_1","verticalBar_1","horizontalBar_2","verticalBar_2","observer_1","wheelContainerOption","firstChild","BounceScrollBar","scrollPos","renderBounce","renderDefault","inject","nonce","wheelContainer","wheelContainerElement","isString","Node","current","events","stop","isMouseEvent","dragFlag","startEvent","dt","time","prevSpeed","isPinch","movement","isDrag","isDouble","_startScrollAnimationBySpeed","startZoom","ResizeObserver","observe","push","disconnect","_e","nextOffsetX","nextOffsetY","viewportStyle","getScrollAreaWidth","getScrollAreaHeight","renderScroll","dest","distRatio","_zoomTimer","_scrollTimer","destPos","cancelAnimationFrame","event","_zoomByClient","rect","getContainer","width","height","originalZoomOffsetX","originalZoomOffsetY","zoomOptions","nextScrollLeft","nextScrollTop","prevScrollLeft","prevScrollTop","_scrollToType","nextScrollAbsoluteLeft","nextScrollAbsoluteTop","_emitScrollEvent","round","move","requestScrollLeft","requestScrollTop","names","prevScrollPos","minCoord","maxCoord","scrollAreaSize","zoomCoord","maxThreshold","rangeCoord","rangeOffsetCoord","isFinite","floor","ceil","_asLeft","_asTop","viewportSize","prototype","property","attributes","enumerable","configurable","get","setter","set","Object","defineProperty","InfiniteViewer","modules"],"mappings":"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"}